-- =====================================================
-- Snowflake API Proxy Service - Database Tables
-- =====================================================
-- This script creates all necessary tables for the API Proxy Service
-- Run this after running setup_service_account.sql
--
-- Prerequisites:
-- 1. Database API_PROXY exists
-- 2. Schema APP exists (created by setup_service_account.sql or deploy.sh)
-- 3. API_PROXY_SERVICE_ROLE has CREATE TABLE permission
--
-- Note: This script expects schema "APP" (not PUBLIC).
-- If using deploy.sh, it creates everything automatically.
-- If running manually, run setup_service_account.sql first.
--
-- =====================================================

-- Run as ACCOUNTADMIN to create tables, then grant permissions
USE ROLE ACCOUNTADMIN;
USE DATABASE API_PROXY;
USE SCHEMA APP;

-- =====================================================
-- 1. USERS TABLE - For authentication
-- =====================================================

CREATE TABLE IF NOT EXISTS USERS (
    USER_ID VARCHAR(36) DEFAULT UUID_STRING(),
    USERNAME VARCHAR(255) NOT NULL UNIQUE,
    PASSWORD_HASH VARCHAR(255) NOT NULL,
    EMAIL VARCHAR(255),
    ROLE VARCHAR(50) DEFAULT 'admin',
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    CREATED_AT TIMESTAMP_LTZ DEFAULT CURRENT_TIMESTAMP(),
    UPDATED_AT TIMESTAMP_LTZ DEFAULT CURRENT_TIMESTAMP(),
    LAST_LOGIN TIMESTAMP_LTZ,
    CREATED_BY VARCHAR(255)
)
CLUSTER BY (USERNAME, IS_ACTIVE);

-- =====================================================
-- 2. ENDPOINTS TABLE - For API endpoint definitions
-- =====================================================

CREATE TABLE IF NOT EXISTS ENDPOINTS (
    ENDPOINT_ID VARCHAR(36) DEFAULT UUID_STRING(),
    NAME VARCHAR(255) NOT NULL,
    DESCRIPTION VARCHAR(1000),
    TYPE VARCHAR(50) NOT NULL, -- 'query', 'stored_procedure', 'function', 'table'
    TARGET VARCHAR(2000) NOT NULL, -- SQL query, procedure name, function name, or table name
    METHOD VARCHAR(10) DEFAULT 'GET', -- HTTP method
    PARAMETERS VARIANT, -- JSON array of parameter definitions
    RATE_LIMIT INTEGER DEFAULT 100, -- Requests per minute
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    CREATED_AT TIMESTAMP_LTZ DEFAULT CURRENT_TIMESTAMP(),
    UPDATED_AT TIMESTAMP_LTZ DEFAULT CURRENT_TIMESTAMP(),
    CREATED_BY VARCHAR(255),
    METADATA VARIANT -- Additional JSON metadata
)
CLUSTER BY (IS_ACTIVE, TYPE);

-- =====================================================
-- 3. PAT_TOKENS TABLE - For Personal Access Tokens
-- =====================================================

CREATE TABLE IF NOT EXISTS PAT_TOKENS (
    TOKEN_ID VARCHAR(36) DEFAULT UUID_STRING(),
    TOKEN VARCHAR(128) NOT NULL UNIQUE, -- Hashed token
    ENDPOINT_ID VARCHAR(36) NOT NULL,
    CREATED_AT TIMESTAMP_LTZ DEFAULT CURRENT_TIMESTAMP(),
    LAST_USED TIMESTAMP_LTZ,
    USAGE_COUNT INTEGER DEFAULT 0,
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    CREATED_BY VARCHAR(255),
    METADATA VARIANT -- Additional JSON metadata
)
CLUSTER BY (TOKEN_ID, IS_ACTIVE);

-- =====================================================
-- 4. CREATE INDEXES (if needed - Snowflake uses clustering keys above)
-- =====================================================

-- Note: Snowflake uses clustering keys instead of traditional indexes
-- The CLUSTER BY clauses above optimize query performance

-- =====================================================
-- 5. GRANT PERMISSIONS
-- =====================================================

-- Grant permissions on tables to the service role (if it exists)
-- Note: If API_PROXY_SERVICE_ROLE doesn't exist, run setup_service_account.sql first
-- or create the role manually, then re-run this section

-- Uncomment the following lines after the role is created:
-- GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE USERS TO ROLE API_PROXY_SERVICE_ROLE;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE ENDPOINTS TO ROLE API_PROXY_SERVICE_ROLE;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE PAT_TOKENS TO ROLE API_PROXY_SERVICE_ROLE;

-- Alternative: Grant to current role for now (will grant to API_PROXY_SERVICE_ROLE later)
-- For now, tables are created and can be accessed by ACCOUNTADMIN

-- =====================================================
-- 6. INSERT DEFAULT ADMIN USER
-- =====================================================
-- Password hash for 'admin123' (bcrypt, cost factor 12)
-- This should be generated by the application, but we include it here for initial setup

-- Note: The password hash should be generated by the application using bcrypt
-- Example: bcrypt.hash('admin123', 12) will generate a hash
-- For now, we'll create a placeholder that needs to be updated
-- The application will generate and store the hash properly

-- Insert default admin user (password: admin123)
-- You should replace this hash with one generated by bcrypt.hash('admin123', 12)
INSERT INTO USERS (USER_ID, USERNAME, PASSWORD_HASH, EMAIL, ROLE, IS_ACTIVE, CREATED_BY)
SELECT 
    UUID_STRING(),
    'admin',
    '$2a$12$Sk0sw.rJyPUmt/TEmfjM/uS.SZvSGBSIALCefvzmrRPjnCzCOAzTC', -- admin123
    'admin@example.com',
    'admin',
    TRUE,
    'system'
WHERE NOT EXISTS (SELECT 1 FROM USERS WHERE USERNAME = 'admin');

-- =====================================================
-- 7. CREATE HELPFUL VIEWS
-- =====================================================

-- View for active endpoints with token info
CREATE OR REPLACE VIEW ENDPOINTS_WITH_TOKENS AS
SELECT 
    e.ENDPOINT_ID,
    e.NAME,
    e.DESCRIPTION,
    e.TYPE,
    e.TARGET,
    e.METHOD,
    e.IS_ACTIVE,
    e.CREATED_AT,
    e.UPDATED_AT,
    e.CREATED_BY,
    CASE WHEN t.TOKEN_ID IS NOT NULL THEN TRUE ELSE FALSE END AS HAS_TOKEN,
    t.TOKEN_ID,
    t.LAST_USED AS TOKEN_LAST_USED,
    t.USAGE_COUNT AS TOKEN_USAGE_COUNT
FROM ENDPOINTS e
LEFT JOIN PAT_TOKENS t ON e.ENDPOINT_ID = t.ENDPOINT_ID AND t.IS_ACTIVE = TRUE;

-- View for endpoint statistics
CREATE OR REPLACE VIEW ENDPOINT_STATISTICS AS
SELECT 
    e.ENDPOINT_ID,
    e.NAME,
    e.TYPE,
    e.IS_ACTIVE,
    COUNT(DISTINCT t.TOKEN_ID) AS TOKEN_COUNT,
    SUM(t.USAGE_COUNT) AS TOTAL_REQUESTS,
    MAX(t.LAST_USED) AS LAST_REQUEST_TIME
FROM ENDPOINTS e
LEFT JOIN PAT_TOKENS t ON e.ENDPOINT_ID = t.ENDPOINT_ID AND t.IS_ACTIVE = TRUE
GROUP BY e.ENDPOINT_ID, e.NAME, e.TYPE, e.IS_ACTIVE;

-- =====================================================
-- 8. VERIFICATION
-- =====================================================

-- Verify tables were created
SHOW TABLES;

-- Verify default user was created
SELECT USER_ID, USERNAME, EMAIL, ROLE, IS_ACTIVE, CREATED_AT
FROM USERS
WHERE USERNAME = 'admin';

-- Display completion message
SELECT 'Database tables created successfully!' AS STATUS;

